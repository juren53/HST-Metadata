#!/usr/bin/python3
#---------------------write-tags-from-csv.py v0.66--------------------------
# This code writes HSTL IPTC tags to all TIFF files listed in a CSV file
# generated by HST PDB.  
# The first row of the downloaded CSV [headers] must be edited to
# match the IPTC labels used below.  e.g Headline, Objectname, Credit, By-line, SpecialInstructions,
# Writer-Editor, Source, By-lineTitle, and Caption-Abstract.
# 
# Created Sat 17 Jun 2023 03:34:20 AM CDT by JAU
# Updated Mon 26 Jun 2023 12:30:58 PM CDT  Added error trap for missing TIFFs from CSV files
# Updated Wed 05 Jul 2023 20:20:58 PM CDT  Added date conversion routine and Date-Created tag v 0.3
# Updated Sun 09 Jul 2023 11:12:06 AM CDT  Added missing file log at end of processing v0.4
# Updated Mon 10 Jul 2023 11:24:40 AM CDT  Added BylineTitle & CopyrightNotice v0.5
# Updated Sun 16 Jul 2023 07:08:23 AM CDT  Removed file backups Added disk info upfront and time info on backend v0.6
# Updated Sun 16 Jul 2023 13:32:45 PM CDT  Added lines in CSV file and TIFFs in working directory message on frontend v.061
# Updated Mon 17 Jul 2023 04:53:54 PM CDT  Added traps for 'Ca.' dates v 0.62
# Updated Mon 17 Jul 2023 08:05:42 PM CDT  Added logging  v 0.63
# Updated Thu 27 Jul 2023 09:24:00 AM CDT  Fixed 'None' date format error via use of formated string v0.64
# Updated Fri 27 Jul 2023 13:21:00 PM CDT  Added short menu to select TIFF or JPEG files in pre-processing v0.65
# updated Fri 10 Aug 2023 18:25:00 PM CDT  Input file name and log file name modified
#----------------------------------------------------------------

import csv
import exiftool
import os
import re
import datetime as dt 
import glob
import shutil
from datetime import datetime
import time
import sys
import logging

#ext="tif"

cwd = os.getcwd()     # Gets current working directory

directory = os.getcwd() # Sets the working directory

# Clear the screen
os.system('cls' if os.name == 'nt' else 'clear')
####################################################


def file_processing_menu():
    global ext  # Declare ext as a global variable to access it outside the function

    ext = None

    while ext is None:
        print("Menu:")
        print("1. Process TIFF files")
        print("2. Process JPEG files")
        choice = input("Enter your choice (1 or 2): ")

        if choice == "1":
            ext = "tif"
        elif choice == "2":
            ext = "jpg"
        else:
            print("Invalid choice. Please try again.")

    print("File extension set to:", ext)
    # Rest of your code using the 'ext' variable goes here


# Call the menu routine
file_processing_menu()


####################################################
# logging screen prints to output.txt file


####################################################

# Create a log file name from ext and datetime

# Get the current date and time
current_datetime = datetime.now()

# Format the date and time as a string
formatted_datetime = current_datetime.strftime("%Y-%m-%d_%H-%M-%S")

# Create a new log filename with the formatted date and time in the filename

if ext.lower() == "tif":
    EXT = "TIFF"

if ext.lower() == "jpg":
    EXT = "JPEG"

#filename = f"REPORT_{formatted_datetime}.txt"
filename = f"REPORT_"+EXT+f"-{formatted_datetime}.txt"

####################################################


try:
    os.remove(filename)   # delete old output.txt 
except FileNotFoundError:     # continue if output.txt not found
    pass 

class OutputLogger:
    def __init__(self, filename):
        self.filename = filename
        self.original_stdout = sys.stdout

    def start_logging(self):
        sys.stdout = self

    def stop_logging(self):
        sys.stdout = self.original_stdout

    def write(self, text):
        with open(self.filename, 'a') as file:
            file.write(text)
        self.original_stdout.write(text)

    def flush(self):
        self.original_stdout.flush()

logger = OutputLogger(filename)
logger.start_logging()

####################################################

# Get free disk space
total, used, free = shutil.disk_usage('/')
free_mb = free / 1024 / 1024 
#print('Free disk space:', free_mb, 'MB')

# Number of lines in CSV file

with open("export.csv", "r") as file:
    reader = csv.reader(file)
    num_lines = sum(1 for row in reader)-1
    #print(f"Number of lines in the file: {num_lines}")


# Print a message
print("=========================================================================")
print("write-tags-from-csv.py ver 0.66  updated Fri 10 Aug 2023 18:25:00 PM CDT ")
print("-------------------------------------------------------------------------")
print(" ")
print("This Python program embeds IPTC metadata tags into TIFF and JPEG files") 
print("listed in a CSV file generated from the HST PDB.")
print(" ")
print("To run correctly, it requires the following in the current working directory: ")
print(" ")
print(" (1) the PDB CSV file with updated IPTC headers")
print(" (2) the TIFF or JPEG files listed in the CSV file")
print(" (3) the Python program [ write-tags-from-csv.py ] ")
print(" ")
print('Free disk space on current drive:', int(free_mb), 'MB')
print(" ")
print(f"Number of lines in the CSV file: {num_lines}")
print(" ")

tiff_files = glob.glob('*.'+ext)
num_tiff_files = len(tiff_files)
print(f"Number of {ext} files in the directory:  {num_tiff_files}")
print(" ")
print("=========================================================================")
print(" ")
print("Press Enter to continue...")

# Wait for the space bar to be pressed
print(" ")
input()

# Start the clock
current_date = datetime.now(None)
print("Processing started at ",current_date.strftime("%Y-%m-%d %H:%M:%S"))
start_time = time.time()


log =""    # initializes missing file log reported at end of run
processed_counter=0  # initializes counter for images processed reported at end of run
missing_counter=0
read_counter=0

with open("export.csv", newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        photo = f"{row['ObjectName']}."+ext
        file_path = os.path.join(directory, photo)  # Construct the full file path
        read_counter=read_counter+1       
        if not os.path.isfile(file_path):
            print(f"***** File {photo} not found in directory {directory} ********")
            log = log+photo+" missing"+"\r\n"
            missing_counter=missing_counter+1
            continue
        print(photo)
        processed_counter=processed_counter+1

    #### Date Conversion Routine #####

        def convert_date(date_str):

            if date_str == 'None':                            # convert NONE to 0000-00-00

                 return f"0000-00-00"
#                date_str = "0000-00-00"
#                date_object = dt.datetime.strptime(date_str, "%Y-%m-%d")  
#
#                #formatted_date = date_object.strftime("%Y-%m-%d")
#              
#                formatted_date = date_object.strftime(f"0000-00-00")
#                return formatted_date
#

  
            if date_str == '\n\n\n\n\n\n\n\n\n\n \n\nHarry':  # convert NONE to 0000-00-00
                return f"0000-00-00"

            elif re.match(r'\d{4}-\d{4}', date_str):          # test for 'thru date' - YYYY - YYYY 
                year_range = date_str.split('-')
                return f"{year_range[1]}-00-00"

            elif re.match(r'\d{1,2}/\d{1,2}/\d{2}', date_str):
                components = date_str.split('/')
                return f"20{components[2]}-{components[0]:0>2}-{components[1]:0>2}"

            elif re.match(r'c\. ?\d{4}', date_str):            # test for circa date eg. c.1939
                year = re.findall(r'\d{4}', date_str)[0]
                return f"{year}-00-00"

            elif re.match(r"ca\. ?\d{4}", date_str):            # test for circa  ca.1939 date
                year = date_str.split(".")[1].strip()
                return f"{year}-00-00"

#########################

            elif re.match(r"Ca\. ?\d{4}", date_str):            # test for circa  Ca.1939 date
                year = date_str.split(".")[1].strip()
                return f"{year}-00-00"

            elif re.match(r"Ca\.  ?\d{2}/\d{4}$", date_str):    # test for circa  Ca. 10/1911 date
                year_month = date_str.split(".")[1].strip()
                month, year = year_month.split("/")
                return f"{year}-{month:0>2}-00"

#########################


            elif re.match(r'\d{1,2}-[A-Za-z]{3}-\d{2}', date_str):   # test for DD-MMM-YY date
                try:
                    date_object = dt.datetime.strptime(date_str, "%d-%b-%y")
                    year = date_object.year
                    if year > 2021:  # assuming 2021 as the cutoff year for 19xx vs. 20xx
                        year -= 100   # Subtract 100 years if the year is greater than 2021
                    formatted_date = date_object.strftime("%Y-%m-%d")
                    return f"{year:0>4}-{formatted_date[5:]}"
                except ValueError:
                    return date_str

            elif re.match(r'\d{4}', date_str):                     # test for 1939 date
                return f"{date_str}-00-00"

            elif re.match(r'[A-Za-z]+, \d{2}/\d{2}/\d{4}', date_str):   #test for Monday, 03/23/1964 date
                try:
                    date_object = dt.datetime.strptime(date_str, "%A, %m/%d/%Y")
                    formatted_date = date_object.strftime("%Y-%m-%d")
                    return formatted_date
                except ValueError:
                    return date_str

            elif re.match(r'[A-Za-z]{3}-\d{2}', date_str):          # test for MMM-YY  e.g. May-62 date
                try:
                    date_object = dt.datetime.strptime(date_str, "%b-%y")
                    year = date_object.year
                    if year > 2021:  # assuming 2021 as the cutoff year for 19xx vs. 20xx
                        year -= 100   # Subtract 100 years if the year is greater than 2021
                    formatted_date = date_object.strftime("19%y-%m-00")
                    return formatted_date
                except ValueError:
                    return date_str

            elif re.match(r'[A-Za-z]+ \d{4}', date_str):              # test for Month YYYY to YYYY-DD-00 eg. July 1948 date
                try:
                    date_object = dt.datetime.strptime(date_str, "%B %Y")
                    formatted_date = date_object.strftime("%Y-%m-00")
                    return formatted_date
                except ValueError:
                    return date_str

            elif re.match(r'[A-Za-z]+, \d{4}', date_str):               # test for July, 1948
                try:
                    date_object = dt.datetime.strptime(date_str, "%B, %Y")
                    formatted_date = date_object.strftime("%Y-%d-00")
                    return formatted_date
                except ValueError:
                   return date_str


            elif re.match(r"([A-Za-z]+) (\d{1,2}), (\d{4})", date_str):  # test for September 18, 1945
                try:
                    date_object = dt.datetime.strptime(date_str, "%B %d, %Y")
                    formatted_date = date_object.strftime("%Y-%m-%d")
                    return formatted_date
                except ValueError:
                    return date_str

            return date_str


        date_str = row["SpecialInstructions"]

        print("Date Created: ",convert_date(date_str),"     ",processed_counter)

        Date = (convert_date(date_str))



        with exiftool.ExifTool() as et:

            

            et.execute(b"-Headline=" + row["Headline"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-Credit=" + row["Credit"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-By-line=" + row["By-line"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-SpecialInstructions=" + row["SpecialInstructions"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-ObjectName=" + row["ObjectName"].encode('utf-8'), file_path.encode('utf-8'))
            #et.execute(b"-Writer-Editor=" + row["Writer-Editor"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-Source=" + row["Source"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-Caption-Abstract=" + row["Caption-Abstract"].encode('utf-8'), file_path.encode('utf-8'))

            et.execute(b"-DateCreated=" + Date.encode('utf-8'), file_path.encode('utf-8'))

            et.execute(b"-CopyrightNotice=" + row["CopyrightNotice"].encode('utf-8'), file_path.encode('utf-8'))

            et.execute(b"-By-lineTitle=" + row["By-lineTitle"].encode('utf-8'), file_path.encode('utf-8'))

            pattern = "*original"
            for file in glob.glob(pattern):
               os.remove(file)

# Processing complete
print("======================================================================")

current_date = datetime.now(None)
print("Processing complete at ",current_date.strftime("%Y-%m-%d %H:%M:%S"))

print(str(read_counter)+" records read from the CSV file")
print(str(processed_counter)+" images processed")
print(str(missing_counter)+" missing images")
print("*** Missing images not processed:")
print(log)

print("___________________________")
end_time = time.time()  # Get the current time again
elapsed_time = end_time - start_time  # Calculate the elapsed time
minutes = int(elapsed_time // 60)  # Convert to minutes
seconds = int(elapsed_time % 60)  # Convert to seconds
print("Elapsed time: {}:{}".format(minutes, seconds)," MM:SS")

#print("Processing time for each image: ",elapsed_time/read_counter," seconds")
print("Processing time for each image: ", round(elapsed_time/read_counter, 2), " seconds")

print(filename+" log file printed to "+cwd)

print("======================================================================")
logger.stop_logging()
