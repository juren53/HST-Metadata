#!/usr/bin/python3
#---------------------write-tags-from-csv.py v0.67--------------------------
# This code writes HSTL IPTC tags to all TIFF files listed in a CSV file
# generated by HST PDB.  
# The first row of the downloaded CSV [headers] must be edited to
# match the IPTC labels used below.  e.g Headline, Objectname, By-line, Source, Year, Month, Day,
# "Ca." for approx. date, CopyrightNotice, and Caption-Abstract.
# 
# Created Sat 17 Jun 2023 03:34:20 AM CDT by JAU
# Updated Mon 26 Jun 2023 12:30:58 PM CDT  Added error trap for missing TIFFs from CSV files
# Updated Wed 05 Jul 2023 20:20:58 PM CDT  Added date conversion routine and Date-Created tag v 0.3
# Updated Sun 09 Jul 2023 11:12:06 AM CDT  Added missing file log at end of processing v0.4
# Updated Mon 10 Jul 2023 11:24:40 AM CDT  Added BylineTitle & CopyrightNotice v0.5
# Updated Sun 16 Jul 2023 07:08:23 AM CDT  Removed file backups Added disk info upfront and time info on backend v0.6
# Updated Sun 16 Jul 2023 13:32:45 PM CDT  Added lines in CSV file and TIFFs in working directory message on frontend v.061
# Updated Mon 17 Jul 2023 04:53:54 PM CDT  Added traps for 'Ca.' dates v 0.62
# Updated Mon 17 Jul 2023 08:05:42 PM CDT  Added logging  v 0.63
# Updated Thu 27 Jul 2023 09:24:00 AM CDT  Fixed 'None' date format error via use of formated string v0.64
# Updated Fri 27 Jul 2023 13:21:00 PM CDT  Added short menu to select TIFF or JPEG files in pre-processing v0.65
# updated Fri 10 Aug 2023 18:25:00 PM CDT  Input file name and log file name modified
# updated Sun 25 May 2025 13:15:00 PM CDT  Modified to work with new CSV header format v0.67
#----------------------------------------------------------------

import csv
import exiftool
import os
import re
import datetime as dt 
import glob
import shutil
from datetime import datetime
import time
import sys
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    filename='date_conversion.log'
)

#ext="tif"

cwd = os.getcwd()     # Gets current working directory

directory = os.getcwd() # Sets the working directory

# Clear the screen
os.system('cls' if os.name == 'nt' else 'clear')
####################################################


def file_processing_menu():
    global ext  # Declare ext as a global variable to access it outside the function

    # For testing, set default to TIFF files
    ext = "tif"
    print("File extension set to:", ext)
    # Rest of your code using the 'ext' variable goes here


# Call the menu routine
file_processing_menu()


####################################################
# logging screen prints to output.txt file


####################################################

# Create a log file name from ext and datetime

# Get the current date and time
current_datetime = datetime.now()

# Format the date and time as a string
formatted_datetime = current_datetime.strftime("%Y-%m-%d_%H-%M-%S")

# Create a new log filename with the formatted date and time in the filename

if ext.lower() == "tif":
    EXT = "TIFF"

if ext.lower() == "jpg":
    EXT = "JPEG"

#filename = f"REPORT_{formatted_datetime}.txt"
filename = f"REPORT_"+EXT+f"-{formatted_datetime}.txt"

####################################################


try:
    os.remove(filename)   # delete old output.txt 
except FileNotFoundError:     # continue if output.txt not found
    pass 

class OutputLogger:
    def __init__(self, filename):
        self.filename = filename
        self.original_stdout = sys.stdout

    def start_logging(self):
        sys.stdout = self

    def stop_logging(self):
        sys.stdout = self.original_stdout

    def write(self, text):
        with open(self.filename, 'a') as file:
            file.write(text)
        self.original_stdout.write(text)

    def flush(self):
        self.original_stdout.flush()

logger = OutputLogger(filename)
logger.start_logging()

####################################################

# Get free disk space
total, used, free = shutil.disk_usage('/')
free_mb = free / 1024 / 1024 
#print('Free disk space:', free_mb, 'MB')

# Number of lines in CSV file

with open("export.csv", "r") as file:
    reader = csv.reader(file)
    num_lines = sum(1 for row in reader)-1
    #print(f"Number of lines in the file: {num_lines}")


# Print a message
print("=========================================================================")
print("write-tags-from-csv.py ver 0.67  updated", datetime.now().strftime("%a %d %b %Y %H:%M:%S %p %Z"))
print("-------------------------------------------------------------------------")
print(" ")
print("This Python program embeds IPTC metadata tags into TIFF and JPEG files") 
print("listed in a CSV file generated from the HST PDB.")
print(" ")
print("To run correctly, it requires the following in the current working directory: ")
print(" ")
print(" (1) the PDB CSV file with updated IPTC headers")
print(" (2) the TIFF or JPEG files listed in the CSV file")
print(" (3) the Python program [ write-tags-from-csv.py ] ")
print(" ")
print('Free disk space on current drive:', int(free_mb), 'MB')
print(" ")
print(f"Number of lines in the CSV file: {num_lines}")
print(" ")

tiff_files = glob.glob('*.'+ext)
num_tiff_files = len(tiff_files)
print(f"Number of {ext} files in the directory:  {num_tiff_files}")
print(" ")
print("=========================================================================")
print(" ")
print("Press Enter to continue...")

# Wait for the space bar to be pressed
print(" ")
# input()  # Commented out for non-interactive testing

# Start the clock
current_date = datetime.now(None)
print("Processing started at ",current_date.strftime("%Y-%m-%d %H:%M:%S"))
start_time = time.time()


log =""    # initializes missing file log reported at end of run
processed_counter=0  # initializes counter for images processed reported at end of run
missing_counter=0
read_counter=0

with open("export.csv", newline='') as csvfile:
    csv_reader = csv.reader(csvfile)
    
    # Get headers (first row)
    try:
        headers = next(csv_reader)
        print(f"DEBUG: Headers loaded: {headers}")
        
        # Find the index of key columns
        source_index = None
        objectname_index = None
        headline_index = None
        byline_index = None
        caption_index = None
        datecreated_index = None
        year_index = None
        month_index = None
        day_index = None
        ca_index = None
        copyright_index = None
        byline_title_index = None
        
        for i, header in enumerate(headers):
            if header == "Source":
                source_index = i
            elif header == "ObjectName":
                objectname_index = i
            elif header == "Headline":
                headline_index = i
            elif header == "By-line":
                byline_index = i
            elif header == "Caption-Abstract":
                caption_index = i
            elif header == "DateCreated":
                datecreated_index = i
            elif header == "Year":
                year_index = i
            elif header == "Month":
                month_index = i
            elif header == "Day":
                day_index = i
            elif header == '"Ca." for approx. date [leave blank if no qualifier]':
                ca_index = i
            elif header == "CopyrightNotice":
                copyright_index = i
            elif header == "By-lineTitle":
                byline_title_index = i
        
        print(f"DEBUG: Found Source at index {source_index}")
        print(f"DEBUG: Found ObjectName at index {objectname_index}")
        
    except StopIteration:
        print("Error: CSV file is empty or has no headers")
        exit(1)
    
    # Process all data rows
    for record in csv_reader:
        # Get ObjectName using index instead of dictionary access
        object_name = ""
        if objectname_index is not None and objectname_index < len(record):
            object_name = record[objectname_index]
        
        photo = f"{object_name}."+ext
        file_path = os.path.join(directory, photo)  # Construct the full file path
        read_counter=read_counter+1       
        if not os.path.isfile(file_path):
            print(f"***** File {photo} not found in directory {directory} ********")
            log = log+photo+" missing"+"\r\n"
            missing_counter=missing_counter+1
            continue
        print(photo)
        processed_counter=processed_counter+1

    #### Date Conversion Routine #####
        def convert_date(date_str):
            try:
                if date_str == 'None':                            # convert NONE to 0000-00-00
                    return f"0000-00-00"
#                date_str = "0000-00-00"
#                date_object = dt.datetime.strptime(date_str, "%Y-%m-%d")  
#
#                #formatted_date = date_object.strftime("%Y-%m-%d")
#              
#                formatted_date = date_object.strftime(f"0000-00-00")
#                return formatted_date
#

  
                if date_str == '\n\n\n\n\n\n\n\n\n\n \n\nHarry':  # convert NONE to 0000-00-00
                    return f"0000-00-00"

                elif re.match(r'\d{4}-\d{4}', date_str):          # test for 'thru date' - YYYY - YYYY 
                    year_range = date_str.split('-')
                    return f"{year_range[1]}-00-00"

                elif re.match(r'\d{1,2}/\d{1,2}/\d{2}', date_str):
                    components = date_str.split('/')
                    return f"20{components[2]}-{components[0]:0>2}-{components[1]:0>2}"

                elif re.match(r'c\. ?\d{4}', date_str):            # test for circa date eg. c.1939
                    year = re.findall(r'\d{4}', date_str)[0]
                    return f"{year}-00-00"

                elif re.match(r"ca\. ?\d{4}", date_str):            # test for circa  ca.1939 date
                    year = date_str.split(".")[1].strip()
                    return f"{year}-00-00"

#########################

                elif re.match(r"Ca\. ?\d{4}", date_str):            # test for circa  Ca.1939 date
                    year = date_str.split(".")[1].strip()
                    return f"{year}-00-00"

                elif re.match(r"Ca\.  ?\d{2}/\d{4}$", date_str):    # test for circa  Ca. 10/1911 date
                    year_month = date_str.split(".")[1].strip()
                    month, year = year_month.split("/")
                    return f"{year}-{month:0>2}-00"

#########################


                elif re.match(r'\d{1,2}-[A-Za-z]{3}-\d{2}', date_str):   # test for DD-MMM-YY date
                    try:
                        date_object = dt.datetime.strptime(date_str, "%d-%b-%y")
                        year = date_object.year
                        if year > 2021:  # assuming 2021 as the cutoff year for 19xx vs. 20xx
                            year -= 100   # Subtract 100 years if the year is greater than 2021
                        formatted_date = date_object.strftime("%Y-%m-%d")
                        return f"{year:0>4}-{formatted_date[5:]}"
                    except ValueError:
                        return date_str

                elif re.match(r'\d{4}', date_str):                     # test for 1939 date
                    return f"{date_str}-00-00"

                elif re.match(r'[A-Za-z]+, \d{2}/\d{2}/\d{4}', date_str):   #test for Monday, 03/23/1964 date
                    try:
                        date_object = dt.datetime.strptime(date_str, "%A, %m/%d/%Y")
                        formatted_date = date_object.strftime("%Y-%m-%d")
                        return formatted_date
                    except ValueError:
                        return date_str

                elif re.match(r'[A-Za-z]{3}-\d{2}', date_str):          # test for MMM-YY  e.g. May-62 date
                    try:
                        date_object = dt.datetime.strptime(date_str, "%b-%y")
                        year = date_object.year
                        if year > 2021:  # assuming 2021 as the cutoff year for 19xx vs. 20xx
                            year -= 100   # Subtract 100 years if the year is greater than 2021
                        formatted_date = date_object.strftime("19%y-%m-00")
                        return formatted_date
                    except ValueError:
                        return date_str

                elif re.match(r'[A-Za-z]+ \d{4}', date_str):              # test for Month YYYY to YYYY-DD-00 eg. July 1948 date
                    try:
                        date_object = dt.datetime.strptime(date_str, "%B %Y")
                        formatted_date = date_object.strftime("%Y-%m-00")
                        return formatted_date
                    except ValueError:
                        return date_str

                elif re.match(r'[A-Za-z]+, \d{4}', date_str):               # test for July, 1948
                    try:
                        date_object = dt.datetime.strptime(date_str, "%B, %Y")
                        formatted_date = date_object.strftime("%Y-%m-00")
                        return formatted_date
                    except ValueError:
                        logging.warning(f"Failed to parse date: {date_str} using format '%B, %Y'")
                        return date_str


                elif re.match(r"([A-Za-z]+) (\d{1,2}), (\d{4})", date_str):  # test for September 18, 1945
                    try:
                        date_object = dt.datetime.strptime(date_str, "%B %d, %Y")
                        formatted_date = date_object.strftime("%Y-%m-%d")
                        return formatted_date
                    except ValueError:
                        return date_str

                logging.warning(f"No pattern matched for date: {date_str}")
                return date_str
                
            except Exception as e:
                logging.error(f"Error converting date '{date_str}': {str(e)}")
                return "0000-00-00"  # Return a safe default on error

        # Get date directly from DateCreated column using index
        date_str = ""
        if datecreated_index is not None and datecreated_index < len(record):
            date_str = record[datecreated_index].strip()
        
        # Keep the legacy date construction for SpecialInstructions and backup
        year = ""
        if year_index is not None and year_index < len(record):
            year = record[year_index].strip()
        
        month = ""
        if month_index is not None and month_index < len(record):
            month = record[month_index].strip()
        
        day = ""
        if day_index is not None and day_index < len(record):
            day = record[day_index].strip()
        
        ca_qualifier = ""
        if ca_index is not None and ca_index < len(record):
            ca_qualifier = record[ca_index].strip()
        
        # Format the legacy date string (for SpecialInstructions only)
        if year:
            if ca_qualifier:
                legacy_date_str = f"Ca. {year}"
                if month:
                    legacy_date_str = f"Ca. {month}/{year}"
            else:
                legacy_date_str = year
                if month:
                    if day:
                        legacy_date_str = f"{month}/{day}/{year}"
                    else:
                        legacy_date_str = f"{month}/{year}"
        else:
            legacy_date_str = "None"
        
        # Use the DateCreated column directly if it exists and is valid
        if date_str and date_str != "":
            # Check if it's already in ISO format (YYYY-MM-DD)
            if re.match(r'^\d{4}-\d{2}-\d{2}$', date_str):
                Date = date_str
                print(f"Using ISO date from DateCreated column: {Date}")
            else:
                # If not in ISO format, try to convert it
                converted_date = convert_date(date_str)
                Date = converted_date
                print(f"Converted DateCreated value: {Date}")
        else:
            # Fall back to the old method if DateCreated is empty
            converted_date = convert_date(legacy_date_str)
            Date = converted_date
            print(f"Using fallback date (no DateCreated column): {Date}")
        
        print("Date Created: ", Date, "     ", processed_counter)



        with exiftool.ExifTool() as et:

            

            # Get headline if available
            headline = ""
            if headline_index is not None and headline_index < len(record):
                headline = record[headline_index]
            et.execute(b"-Headline=" + headline.encode('utf-8'), file_path.encode('utf-8'))
            
            # Hard-code Credit as "Harry S. Truman Library"
            credit = "Harry S. Truman Library"
            et.execute(b"-Credit=" + credit.encode('utf-8'), file_path.encode('utf-8'))
            
            # Get By-line if available
            byline = ""
            if byline_index is not None and byline_index < len(record):
                byline = record[byline_index]
            et.execute(b"-By-line=" + byline.encode('utf-8'), file_path.encode('utf-8'))
            
            # Use the legacy date string for SpecialInstructions
            et.execute(b"-SpecialInstructions=" + legacy_date_str.encode('utf-8'), file_path.encode('utf-8'))
            
            # Get ObjectName if available (already retrieved above, reusing)
            et.execute(b"-ObjectName=" + object_name.encode('utf-8'), file_path.encode('utf-8'))
            
            # Writer-Editor is already commented out
            #et.execute(b"-Writer-Editor=" + row.get("Writer-Editor", "").encode('utf-8'), file_path.encode('utf-8'))
            
            # Get Source if available using index
            source = ""
            if source_index is not None and source_index < len(record):
                source = record[source_index]
            print(f"DEBUG: Source value: '{source}'")  # Debug line
            if source and source.strip():
                et.execute(b"-IPTC:Source=" + source.encode('utf-8'), file_path.encode('utf-8'))
                print(f"Setting IPTC:Source tag to: {source}")
            else:
                print("No Source value found in CSV")
            
            # Get Caption-Abstract if available
            caption = ""
            if caption_index is not None and caption_index < len(record):
                caption = record[caption_index]
            et.execute(b"-Caption-Abstract=" + caption.encode('utf-8'), file_path.encode('utf-8'))
            # Format date for IPTC DateCreated tag (YYYY:MM:DD)
            if Date and Date != "0000-00-00":
                date_parts = Date.split('-')
                if len(date_parts) == 3:
                    iptc_date = f"{date_parts[0]}:{date_parts[1]}:{date_parts[2]}"
                    et.execute(b"-DateCreated=" + iptc_date.encode('utf-8'), file_path.encode('utf-8'))
                    print(f"Setting IPTC DateCreated to: {iptc_date}")
                else:
                    # If date cannot be properly formatted, still try with original format
                    et.execute(b"-DateCreated=" + Date.encode('utf-8'), file_path.encode('utf-8'))
                    print(f"Using original date format for IPTC DateCreated: {Date}")
            else:
                # Handle empty or default date
                et.execute(b"-DateCreated=" + Date.encode('utf-8'), file_path.encode('utf-8'))
                print(f"Using default date for IPTC DateCreated: {Date}")

            # Get CopyrightNotice if available
            copyright_notice = ""
            if copyright_index is not None and copyright_index < len(record):
                copyright_notice = record[copyright_index]
            et.execute(b"-CopyrightNotice=" + copyright_notice.encode('utf-8'), file_path.encode('utf-8'))

            # Get By-lineTitle from the By-lineTitle column
            byline_title = ""
            if byline_title_index is not None and byline_title_index < len(record):
                byline_title = record[byline_title_index]
            et.execute(b"-By-lineTitle=" + byline_title.encode('utf-8'), file_path.encode('utf-8'))

            pattern = "*original"
            for file in glob.glob(pattern):
               os.remove(file)

# Processing complete
print("======================================================================")

current_date = datetime.now(None)
print("Processing complete at ",current_date.strftime("%Y-%m-%d %H:%M:%S"))

print(str(read_counter)+" records read from the CSV file")
print(str(processed_counter)+" images processed")
print(str(missing_counter)+" missing images")
print("*** Missing images not processed:")
print(log)

print("___________________________")
end_time = time.time()  # Get the current time again
elapsed_time = end_time - start_time  # Calculate the elapsed time
minutes = int(elapsed_time // 60)  # Convert to minutes
seconds = int(elapsed_time % 60)  # Convert to seconds
print("Elapsed time: {}:{}".format(minutes, seconds)," MM:SS")

#print("Processing time for each image: ",elapsed_time/read_counter," seconds")
print("Processing time for each image: ", round(elapsed_time/read_counter, 2), " seconds")

print(filename+" log file printed to "+cwd)

print("======================================================================")
logger.stop_logging()
