#!/usr/bin/python3
#---------------------write-tags-from-csv.py v0.61--------------------------
# This code writes HSTL IPTC tags to all TIFF files listed in a CSV file
# generated by HST PDB.  
# The first row of the downloaded CSV [headers] must be edited to
# match the IPTC labels used below.  e.g Credit, By-line, SpecialInstructions,
# Objectname, Writer-Editor, Source, Headline and Caption-Abstract.
# 
#
# Created Sat 17 Jun 2023 03:34:20 AM CDT by JAU
# Updated Mon 26 Jun 2023 12:30:58 PM CDT  Added error trap for missing TIFFs from CSV files
# Updated Wed 05 Jul 2023 20:20:58 PM CDT  Added date conversion routine and Date-Created tag v 0.3
# Updated Sun 09 Jul 2023 11:12:06 AM CDT  Added missing file log at end of processing v0.4
# Updated Mon 10 Jul 2023 11:24:40 AM CDT  Added BylineTitle & CopyrightNotice v0.5
# Updated Sun 16 Jul 2023 07:08:23 AM CDT  Removed file backups Added disk info upfront and time info on backend v0.6
# Updated Sun 16 Jul 2023 13:32:45 PM CDT  Added lines in CSV file and TIFFs in working directory message on frontend v.061
#----------------------------------------------------------------

import csv
import exiftool
import os
import re
import datetime as dt 
import glob
import shutil
from datetime import datetime
import time



cwd = os.getcwd()     # Gets current working directory

directory = os.getcwd() # Sets the working directory

# Clear the screen
os.system('cls' if os.name == 'nt' else 'clear')


# Get free disk space
total, used, free = shutil.disk_usage('/')
free_mb = free / 1024 / 1024 / 1024
#print('Free disk space:', free_mb, 'GB')

# Number of lines in CSV file

with open("sample-tiffs.csv", "r") as file:
    reader = csv.reader(file)
    num_lines = sum(1 for row in reader)-1
    #print(f"Number of lines in the file: {num_lines}")


# Print a message
print("write-tags-from-csv.py ver 0.61  updated Sun 16 Jul 2023 13:32:45 PM CDT")
print(" ")
print("This Python program embeds IPTC metadata tags into TIFF files listed in a CSV file generated from the HST PDB.")
print(" ")
print("This program requires the following in the current working directory: ")
print(" ")
print(" (1) the PDB CSV file with updated IPTC headers")
print(" (2) the TIFF files listed in the CSV file")
print(" (3) the Python program [ write-tags-from-csv.py ] ")
print(" ")
print('Free disk space on current drive:', int(free_mb), 'MB')
print(" ")
print(f"Number of lines in the CSV file: {num_lines}")
print(" ")

tiff_files = glob.glob('*.tif')
num_tiff_files = len(tiff_files)
print(f"Number of TIFF files in the diretory:  {num_tiff_files}")
print(" ")

#print(" ")
print("Press Enter to continue...")

# Wait for the space bar to be pressed
print(" ")
input()

# Start the clock
start_time = time.time()


log =""    # initializes missing file log reported at end of run
processed_counter=0  # initializes counter for images processed reported at end of run
missing_counter=0
read_counter=0

with open("sample-tiffs.csv", newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        filename = f"{row['ObjectName']}.jpg"
        #filename = f"{row['ObjectName']}.tif"
        file_path = os.path.join(directory, filename)  # Construct the full file path
        read_counter=read_counter+1       
        if not os.path.isfile(file_path):
            print(f"***** File {filename} not found in directory {directory} ********")
            log = log+filename+" missing"+"\r\n"
            missing_counter=missing_counter+1
            continue
        print(filename)
        processed_counter=processed_counter+1

        #### Date Conversion Routine #####


        def convert_date(date_str):

            if date_str == 'None':  # convert NONE to 0000-00-00
                return "0000-00-00"
  
            if date_str == '\n\n\n\n\n\n\n\n\n\n \n\nHarry':  # convert NONE to 0000-00-00
                return "0000-00-00"

            elif re.match(r'\d{4}-\d{4}', date_str):     # test for 'thru date' - YYYY - YYYY 
                year_range = date_str.split('-')
                return f"{year_range[1]}-00-00"

            elif re.match(r'\d{1,2}/\d{1,2}/\d{2}', date_str):
                components = date_str.split('/')
                return f"20{components[2]}-{components[0]:0>2}-{components[1]:0>2}"

            elif re.match(r'c\. ?\d{4}', date_str):            # test for circa date eg. c.1939
                year = re.findall(r'\d{4}', date_str)[0]
                return f"{year}-00-00"

            elif re.match(r"ca\. ?\d{4}", date_str):            # test for circa date ca.1939
                year = date_str.split(".")[1].strip()
                return f"{year}-00-00"

            elif re.match(r'\d{1,2}-[A-Za-z]{3}-\d{2}', date_str):   # test for DD-MMM-YY date
                try:
                    date_object = dt.datetime.strptime(date_str, "%d-%b-%y")
                    year = date_object.year
                    if year > 2021:  # assuming 2021 as the cutoff year for 19xx vs. 20xx
                        year -= 100   # Subtract 100 years if the year is greater than 2021
                    formatted_date = date_object.strftime("%Y-%m-%d")
                    return f"{year:0>4}-{formatted_date[5:]}"
                except ValueError:
                    return date_str

            elif re.match(r'\d{4}', date_str):  # 1939
                return f"{date_str}-00-00"

            elif re.match(r'[A-Za-z]+, \d{2}/\d{2}/\d{4}', date_str):   #test for Monday, 03/23/1964
                try:
                    date_object = dt.datetime.strptime(date_str, "%A, %m/%d/%Y")
                    formatted_date = date_object.strftime("%Y-%m-%d")
                    return formatted_date
                except ValueError:
                    return date_str

            elif re.match(r'[A-Za-z]{3}-\d{2}', date_str):   # test for MMM-YY date e.g. May-62
                try:
                    date_object = dt.datetime.strptime(date_str, "%b-%y")
                    year = date_object.year
                    if year > 2021:  # assuming 2021 as the cutoff year for 19xx vs. 20xx
                        year -= 100   # Subtract 100 years if the year is greater than 2021
                    formatted_date = date_object.strftime("19%y-%m-00")
                    return formatted_date
                except ValueError:
                    return date_str

            elif re.match(r'[A-Za-z]+ \d{4}', date_str):  # test for Month YYYY to YYYY-DD-00 eg. July 1948
                try:
                    date_object = dt.datetime.strptime(date_str, "%B %Y")
                    formatted_date = date_object.strftime("%Y-%m-00")
                    return formatted_date
                except ValueError:
                    return date_str

            elif re.match(r'[A-Za-z]+, \d{4}', date_str):  # test for July, 1948
                try:
                    date_object = dt.datetime.strptime(date_str, "%B, %Y")
                    formatted_date = date_object.strftime("%Y-%d-00")
                    return formatted_date
                except ValueError:
                   return date_str


            elif re.match(r"([A-Za-z]+) (\d{1,2}), (\d{4})", date_str):  # test for September 18, 1945
                try:
                    date_object = dt.datetime.strptime(date_str, "%B %d, %Y")
                    formatted_date = date_object.strftime("%Y-%m-%d")
                    return formatted_date
                except ValueError:
                    return date_str

            return date_str


        date_str = row["SpecialInstructions"]

        print("Date Created: ",convert_date(date_str),"     ",processed_counter)

        Date = (convert_date(date_str))



        with exiftool.ExifTool() as et:

            

            et.execute(b"-Headline=" + row["Headline"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-Credit=" + row["Credit"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-By-line=" + row["By-line"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-SpecialInstructions=" + row["SpecialInstructions"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-ObjectName=" + row["ObjectName"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-Writer-Editor=" + row["Writer-Editor"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-Source=" + row["Source"].encode('utf-8'), file_path.encode('utf-8'))
            et.execute(b"-Caption-Abstract=" + row["Caption-Abstract"].encode('utf-8'), file_path.encode('utf-8'))

            et.execute(b"-DateCreated=" + Date.encode('utf-8'), file_path.encode('utf-8'))

            et.execute(b"-CopyrightNotice=" + row["CopyrightNotice"].encode('utf-8'), file_path.encode('utf-8'))

            et.execute(b"-By-lineTitle=" + row["By-lineTitle"].encode('utf-8'), file_path.encode('utf-8'))

            #et.execute(b"-DateCreated=" + Date.encode('utf-8'), filename.encode('utf-8'))

            pattern = "*original"
            for file in glob.glob(pattern):
               os.remove(file)

# Processing complete
print("======================================================================")


#print("Processing complete at ", datetime.now("%Y-%m-%d %H:%M:%S"))

current_date = datetime.now(None)
print("Processing complete at ",current_date.strftime("%Y-%m-%d %H:%M:%S"))

print(str(read_counter)+" records read from the CSV file")
print(str(processed_counter)+" images processed")
print(str(missing_counter)+" missing images")
print("*** Missing images not processed:")
print(log)

print("___________________________")
end_time = time.time()  # Get the current time again
elapsed_time = end_time - start_time  # Calculate the elapsed time
minutes = int(elapsed_time // 60)  # Convert to minutes
seconds = int(elapsed_time % 60)  # Convert to seconds
print("Elapsed time: {}:{}".format(minutes, seconds)," MM:SS")

#print("Processing time for each image: ",elapsed_time/read_counter," seconds")
print("Processing time for each image: ", round(elapsed_time/read_counter, 2), " seconds")


print("======================================================================")
